from TIN_engine import *
import uuid

class Node:
    def __init__(self, point):
        self.point: tuple = point
        self.upstream_nodes: list[Node] = [] # parents
        self.downstream_node: Node = None # child
        self.id = str(uuid.uuid4())

from TIN_draw import *

"""
def is_node_in_network(node: Node, downstream: Node, depth=0) -> bool:
    if depth > 100:
        print("WARNING: maximum recursion depth reached in is_node_in_network")
        return True
    
    if downstream.id == node.id:
        return True

    for upstream in downstream.upstream_nodes:
        if is_node_in_network(node, upstream, depth + 1):
            return True
    
    return False

def is_node_already_in_outlet(node: Node, outlet: Node) -> bool:
    if outlet.id == node.id:
        return True
    
    # get downstream node
    next = outlet
    while next.downstream_node is not None:
        if next.id == node.id:
            return True
        next = next.downstream_node
    
    return is_node_in_network(node, next) if next is not None else False
"""

def is_node_already_in_outlet(node: Node, outlet: Node) -> bool:
    return False

# ---- Preprocessing ----

# This function was generated by Copilot Code Completion
# It gets all the flat triangles in a list of triangles
def get_flat_triangles(triangles: list[Triangle]):
    flat_triangles = []
    for triangle in triangles:
        v1, v2, v3 = triangle.vertices()
        if v1.z == v2.z == v3.z:
            flat_triangles.append(triangle)
    
    return flat_triangles

# This function was generated by Copilot Code Completion
# Returns True if there are any flat triangles in the list, False otherwise
def has_flat_triangles(triangles: list[Triangle]) -> bool:
    for triangle in triangles:
        v1, v2, v3 = triangle.vertices()
        if v1.z == v2.z == v3.z:
            return True
    
    return False

# This function was generated by Copilot Code Completion
def unflaten_triangles(triangles: list[Triangle]) -> list[Triangle]:
    for triangle in triangles:
        v1, v2, v3 = triangle.vertices()
        if v1.z == v2.z == v3.z:
            # modify the z value of one vertex slightly (TODO: should use some form of linear interpolation instead)
            v3.z += 0.0001

# ---- Main Functions ----

def calculate_steepest_descent_line2(start_triangle: Triangle, triangles: list[Triangle], triangle_to_outlet_node: dict[Triangle, Node], max_steps: int = 1000):
    current_triangle = start_triangle
    current_triangle_descent_cached = None # TODO

    current_point = current_triangle.get_centroid().coord()
    current_node = Node(current_point)
    previous_z = current_point[2]
    onEdge = False
    current_edge = None
    current_vertex = None
    onVertex = False

    previous_triangles = set()
    previous_triangles.add(current_triangle)

    for i in range(1, max_steps + 1):
        if i >= max_steps - 1:
            print("RETURN: reached max steps, stopping at iteration ", i)
        
        if not onEdge and not onVertex: # needs: current_triangle, current_node, current_point

            if current_triangle in triangle_to_outlet_node:
                # connect to existing outlet node
                existing_outlet_node = triangle_to_outlet_node[current_triangle]
                if is_node_already_in_outlet(current_node, existing_outlet_node):
                    print("RETURN: LOOP detected, stopping at iteration (triangle)", i)
                else:
                    current_node.downstream_node = existing_outlet_node
                    existing_outlet_node.upstream_nodes.append(current_node)
                return None

            descent = calculate_steepest_descent2(current_triangle)
            descent = descent / np.linalg.norm(descent)
            descent *= 0.001

            next_point, adj_tri, v1, v2 = get_point_and_adj_triangle_from_descent2(current_triangle, current_point[0:2], descent)
            if next_point is None:
                print("Error: returning: next_point should not be None, stopping at iteration ", i)
                break

            new_node = Node((next_point[0], next_point[1], previous_z))
            new_node.upstream_nodes.append(current_node)
            current_node.downstream_node = new_node
            triangle_to_outlet_node[current_triangle] = new_node

            current_node = new_node
            current_point = next_point
            previous_z = new_node.point[2]

            if adj_tri is None:
                print("Error: returning: No adjacent triangle found, stopping at iteration ", i)
                break

            current_triangle = adj_tri 
            previous_triangles.add(current_triangle)
            current_edge = (v1, v2)
            onEdge = True
            onVertex = False
        elif onEdge: # needs current_triangle (set to the adjacent triangle), current_node, current_edge
            if current_triangle in triangle_to_outlet_node:
                # connect to existing outlet node
                existing_outlet_node = triangle_to_outlet_node[current_triangle]
                if is_node_already_in_outlet(current_node, existing_outlet_node):
                    print("RETURN: LOOP detected, stopping at iteration (edge)", i)
                else:
                    current_node.downstream_node = existing_outlet_node
                    existing_outlet_node.upstream_nodes.append(current_node)
                    #print("RETURN: Connecting to existing outlet node, stopping! (edge)")
                return None

            descent_current = calculate_steepest_descent2(current_triangle) # gh from p. 1239, Jones et al.

            if current_edge is None:
                TIN_log("ERROR: current_edge is None while onEdge is True")
                break

            v1, v2 = current_edge

            # TODO: make sure no refernce errors here
            current_triangle = make_triangle_counterclockwise2(current_triangle)

            if (current_triangle.vertices().index(v1) + 1) % 3 == current_triangle.vertices().index(v2): # if v1 comes before v2 
                ij = v2.coord() - v1.coord()
            else: # v2 comes before v1
                # swap
                temp = v1
                v1 = v2
                v2 = temp

                ij = v2.coord() - v1.coord()

            # direction of the current triangle: if positive then current triangle slopes toward the current edge
            direction = utils.cross_2D(np.array(descent_current), ij[0:2])

            if direction < 0:
                # slopes away from edge case
                
                # current_triangle, current_point, and current_node are already set to the correct values, do triangle case
                onEdge = False
                onVertex = False
            else:
                # slopes toward edge case

                # go down to lowest vertex
                lowest = None
                if v1.z > v2.z:
                    lowest = v2
                else:
                    lowest = v1
                
                new_node = Node(lowest.coord())
                new_node.upstream_nodes.append(current_node)
                current_node.downstream_node = new_node
                triangle_to_outlet_node[current_triangle] = new_node

                current_node = new_node
                current_point = lowest.coord()
                previous_z = lowest.z

                current_vertex = lowest

                onEdge = False
                onVertex = True
        elif onVertex:
            if round(current_vertex.x, 3) == -116.567 and round(current_vertex.y, 3) == 49.505:
                TIN_log("DEBUG: reached specific vertex at iteration ")

            ordered = get_all_triangles_and_edges_at_point(current_vertex, triangles) # TODO: inefficent, need to optimize
            previous_item = None
            next_item = None
            j = 0
            next_point = None
            next_triangle = None
            adj_triangles = []
            for item in ordered:
                previous_item = ordered[(j - 1) % len(ordered)]
                next_item = ordered[(j + 1) % len(ordered)]

                if isinstance(item, Triangle):
                    if test_triangle(current_vertex, item):
                        if item not in previous_triangles:
                            if next_triangle is None or item.get_centroid().z < next_triangle.get_centroid().z: # pick lowest triangle (TODO: could be better)
                                next_triangle = item
                else: # must be an edge
                    # next_item and previous_item should be triangles adjacent to this edge
                    if test_edge(current_vertex, item, next_item, previous_item):
                        possible_next_point = get_other_vertex_from_edge(current_vertex, item)
                        if next_point is None or possible_next_point.z < next_point.z:
                            next_point = possible_next_point # pick lower point

                            adj_triangles = []
                            adj_triangles.append(next_item)
                            adj_triangles.append(previous_item)
                
                j += 1
            
            if next_point is not None:
                if adj_triangles[0] in triangle_to_outlet_node and adj_triangles[0] not in previous_triangles:
                    existing_outlet_node = triangle_to_outlet_node[adj_triangles[0]]
                    
                    if is_node_already_in_outlet(current_node, existing_outlet_node):
                        print("RETURN: LOOP detected, stopping at iteration (1)", i)
                    else:
                        # connect to existing outlet node
                        current_node.downstream_node = existing_outlet_node
                        existing_outlet_node.upstream_nodes.append(current_node)
                        return None
                elif adj_triangles[1] in triangle_to_outlet_node and adj_triangles[1] not in previous_triangles:
                    existing_outlet_node = triangle_to_outlet_node[adj_triangles[1]]
                    if is_node_already_in_outlet(current_node, existing_outlet_node):
                        print("RETURN: LOOP detected, stopping at iteration (2)", i)
                    else:
                        # connect to existing outlet node
                        current_node.downstream_node = existing_outlet_node
                        existing_outlet_node.upstream_nodes.append(current_node)
                        return None

                new_node = Node(next_point.coord())
                new_node.upstream_nodes.append(current_node)
                current_node.downstream_node = new_node

                # add the two adjacent triangles that share this channel edge
                if adj_triangles[0] not in triangle_to_outlet_node and adj_triangles[0] is not None:
                    triangle_to_outlet_node[adj_triangles[0]] = new_node
                else:
                    TIN_log("WARNING: adjacent triangle 0 already has an outlet node assigned.")
                
                if adj_triangles[1] not in triangle_to_outlet_node and adj_triangles[1] is not None:
                    triangle_to_outlet_node[adj_triangles[1]] = new_node
                else:
                    TIN_log("WARNING: adjacent triangle 1 already has an outlet node assigned.")

                current_node = new_node
                current_point = next_point.coord()
                previous_z = next_point.z

                current_vertex = next_point

                onEdge = False
                onVertex = True
            elif next_triangle is not None:
                current_triangle = next_triangle
                previous_triangles.add(current_triangle)

                onEdge = False
                onVertex = False
            else:
                # need to stop here, no where to go (in a pit)
                break

    return current_node


# See Freitas et al. 2016
def create_drainage_network(triangles: list[Triangle]) -> list[Node]:
    triangle_to_outlet_node = {}  # mapping from triangle id to outlet node
    outlet_nodes = []

    # sort triangles by elevation
    sorted_triangles = sorted(triangles, key=lambda t: t.get_centroid().z, reverse=True)

    i = 0
    for triangle in sorted_triangles:
        outlet = calculate_steepest_descent_line2(triangle, sorted_triangles, triangle_to_outlet_node)

        if outlet is not None:
            outlet_nodes.append(outlet) # new outlet node created
        # else: already connected to existing outlet node

        i += 1
    
    # inefficent, but simple way to merge duplicate outlet nodes
    for node in outlet_nodes:
        for node2 in outlet_nodes:
            if np.array_equal(node.point, node2.point) and node.id != node2.id:
                # merge node2 into node
                for upstream in node2.upstream_nodes:
                    if upstream not in node.upstream_nodes:
                        node.upstream_nodes.append(upstream)
                        upstream.downstream_node = node
                outlet_nodes.remove(node2)
                break
    
    return outlet_nodes
