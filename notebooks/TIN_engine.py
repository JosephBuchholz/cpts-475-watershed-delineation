import numpy as np
import utils
from TIN_types import TIN_log, Vertex, Triangle

def convert_to_triangle_objects(triangles, xs, ys, zs):
    triangle_objects = []
    for i in range(len(triangles)):
        t = triangles[i]
        v1 = Vertex(xs[t[0]], ys[t[0]], zs[t[0]], t[0])
        v2 = Vertex(xs[t[1]], ys[t[1]], zs[t[1]], t[1])
        v3 = Vertex(xs[t[2]], ys[t[2]], zs[t[2]], t[2])
        triangle_objects.append(Triangle(v1, v2, v3, None, None, None, i))
    
    # This for loop was generated by AI (Copilot Code Completion)
    for i in range(len(triangle_objects)):
        t = triangle_objects[i]
        adjacents = []
        for j in range(len(triangle_objects)):
            if i == j:
                continue
            t2 = triangle_objects[j]
            shared_vertices = set([t.v1.id, t.v2.id, t.v3.id]).intersection(set([t2.v1.id, t2.v2.id, t2.v3.id]))
            if len(shared_vertices) == 2:
                adjacents.append(t2)
        
        #if len(adjacents) != 3:
        #    print("Warning: Triangle ", i, " does not have exactly 3 adjacent triangles (has ", len(adjacents), ")")
        
        # assign adjacent triangles (or None if not enough)
        t.a1 = adjacents[0] if len(adjacents) > 0 else None
        t.a2 = adjacents[1] if len(adjacents) > 1 else None
        t.a3 = adjacents[2] if len(adjacents) > 2 else None
    
    return triangle_objects

# similar to convert_to_triangle_objects, but also returns a list of unique Vertex objects
# should also be more efficent, about O(n) (while previous was O(n^2))
# TODO: there seems to be some problems, but works for now
def convert_to_triangle_and_vertex_objects(triangles, xs, ys, zs):
    triangle_objects = []
    vertices = {}
    for i in range(len(triangles)):
        t = triangles[i]
        v1 = Vertex(xs[t[0]], ys[t[0]], zs[t[0]], t[0])
        if v1.id not in vertices:
            vertices[v1.id] = v1
        else:
            v1 = vertices[v1.id]

        v2 = Vertex(xs[t[1]], ys[t[1]], zs[t[1]], t[1])
        if v2.id not in vertices:
            vertices[v2.id] = v2
        else:
            v2 = vertices[v2.id]

        v3 = Vertex(xs[t[2]], ys[t[2]], zs[t[2]], t[2])
        if v3.id not in vertices:
            vertices[v3.id] = v3
        else:
            v3 = vertices[v3.id]
        
        if not v1.is_vertex_connected(v2):
            v1.connected_vertices.append(v2)
        if not v1.is_vertex_connected(v3):
            v1.connected_vertices.append(v3)

        if not v2.is_vertex_connected(v1):
            v2.connected_vertices.append(v1)
        if not v2.is_vertex_connected(v3):
            v2.connected_vertices.append(v3)
        
        if not v3.is_vertex_connected(v1):
            v3.connected_vertices.append(v1)
        if not v3.is_vertex_connected(v2):
            v3.connected_vertices.append(v2)

        triangle = Triangle(v1, v2, v3, None, None, None, i)
        v1.connected_triangles.append(triangle)
        v2.connected_triangles.append(triangle)
        v3.connected_triangles.append(triangle)
        triangle_objects.append(triangle)

    for i in range(len(triangle_objects)):
        current_triangle = triangle_objects[i]

        adjacents = []

        for v in current_triangle.vertices():
            if current_triangle not in v.connected_triangles:
                TIN_log("Error: triangle not in vertex's connected triangles")
            
            for connected_triangle in v.connected_triangles:
                if connected_triangle.id == current_triangle.id:
                    continue

                shared_vertices = set([current_triangle.v1.id, current_triangle.v2.id, current_triangle.v3.id]).intersection(set([connected_triangle.v1.id, connected_triangle.v2.id, connected_triangle.v3.id]))
                if len(shared_vertices) == 2 and connected_triangle not in adjacents:
                    adjacents.append(connected_triangle)
        
        if len(adjacents) < 1 or len(adjacents) > 3:
            TIN_log("Warning: Triangle " + str(i) + " has less than 1 adjacent triangles or greater than 3 (has " + str(len(adjacents)) + ")")

        # assign adjacent triangles (or None if not enough)
        current_triangle.a1 = adjacents[0] if len(adjacents) > 0 else None
        current_triangle.a2 = adjacents[1] if len(adjacents) > 1 else None
        current_triangle.a3 = adjacents[2] if len(adjacents) > 2 else None

    return triangle_objects, vertices

# "sign" and "point_in_triangle" see https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle
def sign(p1, p2, p3):
    return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])

# returns True if the point is inside the given triangle, otherwise False
def point_in_triangle(point, triangle):
    d1 = sign(point, triangle[0], triangle[1])
    d2 = sign(point, triangle[1], triangle[2])
    d3 = sign(point, triangle[2], triangle[0])
    
    has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)
    has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)

    return not (has_neg and has_pos)

# AI (Google AI Overview) wrote the code for this function:
def line_segment_line_intersection(p1, p2, q1, v):
    """
    Finds the intersection point of a line segment and a line in 2D.

    Args:
        p1 (np.array): Start point of the line segment (e.g., np.array([x1, y1])).
        p2 (np.array): End point of the line segment (e.g., np.array([x2, y2])).
        q1 (np.array): A point on the line (e.g., np.array([qx, qy])).
        v (np.array): Direction vector of the line (e.g., np.array([vx, vy])).

    Returns:
        np.array or None: The intersection point if it exists on the segment, otherwise None.
    """
    
    A = np.array([p2 - p1, -v]).T  # Matrix for coefficients of t and s
    b = q1 - p1                   # Right-hand side vector

    # Check for parallel lines (determinant of A close to zero)
    if np.isclose(np.linalg.det(A), 0):
        # Lines are parallel, no unique intersection or infinite intersections
        return None 

    try:
        ts = np.linalg.solve(A, b)
        t, s = ts[0], ts[1]

        if 0 <= t <= 1 and s >= 0:  # Check if intersection is on the line segment
            intersection_point = p1 + t * (p2 - p1)
            return intersection_point
        else:
            return None  # Intersection is outside the line segment
    except np.linalg.LinAlgError:
        return None # No solution (e.g., singular matrix if lines are parallel)

def get_real_vertex_3D(vertex, xs, ys, zs):
    return np.array([xs[vertex], ys[vertex], zs[vertex]])

def get_real_vertex_2D(vertex, xs, ys, zs):
    return np.array([xs[vertex], ys[vertex]])

# translates the given triangle that contains only the indicies of each vertex into a triangle that
# contains the actual values for each vertex (ignores z)
def get_full_2D_triangle(triangle, xs, ys, zs):
    return np.array([[xs[triangle[0]], ys[triangle[0]]], [xs[triangle[1]], ys[triangle[1]]], [xs[triangle[2]], ys[triangle[2]]]])

def get_full_3D_triangle(triangle, xs, ys, zs):
    return np.array([[xs[triangle[0]], ys[triangle[0]], zs[triangle[0]]],
            [xs[triangle[1]], ys[triangle[1]], zs[triangle[1]]],
            [xs[triangle[2]], ys[triangle[2]], zs[triangle[2]]]])

def get_triangle_at(point, triangles, xs, ys, zs):
    for triangle in triangles:
        if isinstance(triangle, Triangle):
            triangle = triangle.convert_to_indices()

        full = get_full_2D_triangle(triangle, xs, ys, zs)
        if point_in_triangle(point, full):
            return triangle

    print("Failed to get triangle for point")
    return False

def get_triangles_with_edge_new(v1: Vertex, v2: Vertex):
    triangles_result = [] # there should only ever be two triangles that share the same edge

    triangles = set(v1.connected_triangles)
    triangles.update(v2.connected_triangles)

    for triangle in triangles:
        if v1 in triangle.vertices() and v2 in triangle.vertices():
            triangles_result.append(triangle)

    if len(triangles_result) > 2:
        TIN_log("ERROR: too many triangles with the same specified edge: ", v1, ", ", v2)
    
    return triangles_result

def get_triangles_with_edge(p1, p2, triangles):
    triangle_list = [] # there should only ever be two triangles that share the same edge

    for triangle in triangles:
        # this is not the best way to do it, but it was quick and easy
        if triangle[0] == p1 and triangle[1] == p2:
            triangle_list.append(triangle)
        elif triangle[1] == p1 and triangle[2] == p2:
            triangle_list.append(triangle)
        elif triangle[2] == p1 and triangle[0] == p2:
            triangle_list.append(triangle)
        elif triangle[0] == p2 and triangle[1] == p1:
            triangle_list.append(triangle)
        elif triangle[1] == p2 and triangle[2] == p1:
            triangle_list.append(triangle)
        elif triangle[2] == p2 and triangle[0] == p1:
            triangle_list.append(triangle)

    if len(triangle_list) != 2:
        print("Failed getting 2 triangles with the same specified edge: ", p1, ", ", p2)
    
    return triangle_list

# see Jones et al. (p. 1237)
def calculate_steepest_descent(triangle):
    x = (triangle[0][0], triangle[1][0], triangle[2][0])
    y = (triangle[0][1], triangle[1][1], triangle[2][1])
    z = (triangle[0][2], triangle[1][2], triangle[2][2])

    A = y[0] * (z[1] - z[2]) + y[1] * (z[2] - z[0]) + y[2] * (z[0] - z[1])
    B = z[0] * (x[1] - x[2]) + z[1] * (x[2] - x[0]) + z[2] * (x[0] - x[1])
    C = x[0] * (y[1] - y[2]) + x[1] * (y[2] - y[0]) + x[2] * (y[0] - y[1])
    #D = -(A * x[0]) - (B * y[0]) - (C * z[1])

    descent = [(A / C), (B / C)]
    return descent

# see Jones et al. (p. 1237)
def calculate_steepest_descent2(triangle: Triangle):
    x = (triangle.v1.x, triangle.v2.x, triangle.v3.x)
    y = (triangle.v1.y, triangle.v2.y, triangle.v3.y)
    z = (triangle.v1.z, triangle.v2.z, triangle.v3.z)

    A = y[0] * (z[1] - z[2]) + y[1] * (z[2] - z[0]) + y[2] * (z[0] - z[1])
    B = z[0] * (x[1] - x[2]) + z[1] * (x[2] - x[0]) + z[2] * (x[0] - x[1])
    C = x[0] * (y[1] - y[2]) + x[1] * (y[2] - y[0]) + x[2] * (y[0] - y[1])
    #D = -(A * x[0]) - (B * y[0]) - (C * z[1])

    descent = [(A / C), (B / C)]
    return descent

def get_point_from_descent(triangle, start, descent, xs, ys, zs):
    full = get_full_2D_triangle(triangle, xs, ys, zs)

    intersection = line_segment_line_intersection(full[0], full[1], start, descent)
    if intersection is not None:
        return (intersection, triangle[0], triangle[1])
    intersection = line_segment_line_intersection(full[1], full[2], start, descent)
    if intersection is not None:
        return (intersection, triangle[1], triangle[2])
        
    intersection = line_segment_line_intersection(full[2], full[0], start, descent)

    if intersection is None:
        print("ERROR: next_point should never be None")

    return (intersection, triangle[2], triangle[0])

# modifed to use triangle objects
def get_point_from_descent2(triangle: Triangle, start, descent):
    intersection = line_segment_line_intersection(triangle.v1.coord2D(), triangle.v2.coord2D(), start, descent)
    if intersection is not None:
        return (intersection, triangle.v1, triangle.v2)
    intersection = line_segment_line_intersection(triangle.v2.coord2D(), triangle.v3.coord2D(), start, descent)
    if intersection is not None:
        return (intersection, triangle.v2, triangle.v3)
        
    intersection = line_segment_line_intersection(triangle.v3.coord2D(), triangle.v1.coord2D(), start, descent)

    if intersection is None:
        print("ERROR: next_point should never be None")

    return (intersection, triangle.v3, triangle.v1)

# really long name, but does the same as "get_point_from_descent" except it
# also gets the other, adjacent triangle that touches the intersection point
def get_point_and_adj_triangle_from_descent(triangle, start, descent, xs, ys, zs, triangles):
    intersection, v1, v2 = get_point_from_descent(triangle, start, descent, xs, ys, zs)

    adj_triangles = get_triangles_with_edge(v1, v2, triangles)
    if len(adj_triangles) != 2:
        print("Error: not enough (or too many) triangles")
        return (intersection, None, v1, v2)
    
    current_tri = None
    adj_tri = None
    if np.array_equal(adj_triangles[0], np.array(triangle)):
        current_tri = adj_triangles[0]
        adj_tri = adj_triangles[1]
    elif np.array_equal(adj_triangles[1], np.array(triangle)):
        current_tri = adj_triangles[1]
        adj_tri = adj_triangles[0]
    else:
        print("Error: this should not happen, one of the triangles must be equal")
    
    return (intersection, adj_tri, v1, v2)

# modifed to use triangle objects
def get_point_and_adj_triangle_from_descent2(triangle: Triangle, start, descent):
    intersection, v1, v2 = get_point_from_descent2(triangle, start, descent)

    adj_triangles = get_triangles_with_edge_new(v1, v2)
    if len(adj_triangles) != 2:
        TIN_log("Error: not enough (or too many) triangles")
        return (intersection, None, v1, v2)
    
    current_tri = None
    adj_tri = None
    if adj_triangles[0] == triangle:
        current_tri = adj_triangles[0]
        adj_tri = adj_triangles[1]
    elif adj_triangles[1] == triangle:
        current_tri = adj_triangles[1]
        adj_tri = adj_triangles[0]
    else:
        print("Error: this should not happen, one of the triangles must be equal")
    
    return (intersection, adj_tri, v1, v2)

# see: https://math.stackexchange.com/questions/1324179/how-to-tell-if-3-connected-points-are-connected-clockwise-or-counter-clockwise
# triangle should be an array of three points (e.g. [[x1, y1, z1], [x2, y2, z2], [x3, y3, z3]])
def is_clockwise(triangle):
    matrix = np.array([[triangle[0][0], triangle[0][1], 1],
                       [triangle[1][0], triangle[1][1], 1],
                       [triangle[2][0], triangle[2][1], 1]])
    
    det = np.linalg.det(matrix)

    if det < 0:
        return True # clockwise
    else:
        return False # counterclockwise

def make_triangle_counterclockwise(triangle):
    if is_clockwise(triangle):
        return triangle[::-1] # reverse the array
    
    return triangle # already counterclockwise

def is_clockwise2(triangle: Triangle):
    matrix = np.array([[triangle.v1.x, triangle.v1.y, 1],
                       [triangle.v2.x, triangle.v2.y, 1],
                       [triangle.v3.x, triangle.v3.y, 1]])
    
    det = np.linalg.det(matrix)

    if det < 0:
        return True # clockwise
    else:
        return False # counterclockwise

def make_triangle_counterclockwise2(triangle: Triangle):
    if is_clockwise2(triangle):
        v1 = triangle.v1
        #v2 = triangle.v2
        v3 = triangle.v3

        triangle.v1 = v3
        #triangle.v2 = v2
        triangle.v3 = v1

        return triangle
    
    return triangle # already counterclockwise

def find_row_index(array, row):
    index = 0
    for r in array:
        if np.array_equal(r, row):
            return index
        
        index += 1
    
    print("Failed to find row")
    return None

def get_all_triangles_with_point(vertex, triangle_objects):
    result = []
    for triangle in triangle_objects:
        if triangle.triangle_has_vertex(vertex):
            result.append(triangle)
    
    return result

# This function was generated with AI (Copilot Code Completion)
# Could be optimized further, but works for now
# Gets all unique edges connected to the given vertex from the list of triangles
# Note: probably not needed anymore
def get_all_edges_with_point(vertex, triangles_with_point):
    edges = []
    for triangle in triangles_with_point:
        for i in range(3):
            v1 = triangle.vertices()[i]
            v2 = triangle.vertices()[(i + 1) % 3]

            if vertex.id == v1.id or vertex.id == v2.id:
                edge = (v1, v2)
                reverse_edge = (v2, v1)

                if edge not in edges and reverse_edge not in edges:
                    edges.append(edge)
    
    return edges

# Gets all the triangles and edges connected to the given vertex as a list
# The list contains Triangle objects and Edge objects in order
def get_all_triangles_and_edges_at_point(vertex, triangles):
    triangles_with_point = get_all_triangles_with_point(vertex, triangles)
    #edges_with_point = get_all_edges_with_point(vertex, triangles_with_point)

    result = []
    current_triangle = triangles_with_point[0]
    result.append(current_triangle)
    while True:
        # long name, but descriptive (:
        found_adj_triangle_that_has_not_been_visited = False
        for adj_triangle in current_triangle.adjacent_triangles():
            if adj_triangle is None or vertex not in adj_triangle.vertices() or adj_triangle in result:
                continue # triangle is not connected to the vertex or already visited that triangle
            
            # triangle is connected to the vertex
            found_adj_triangle_that_has_not_been_visited = True
            edge = current_triangle.get_shared_edge(adj_triangle)
            result.append(edge)
            result.append(adj_triangle)
            current_triangle = adj_triangle
            break

        if not found_adj_triangle_that_has_not_been_visited:
            last_edge = result[0].get_shared_edge(result[-1])
            if last_edge is not None:
                result.append(result[0].get_shared_edge(result[-1]))
            else:
                print("Error: last edge is None")
            
            break # no more adjacent triangles to visit

    # result should contain triangles and edges in order either clockwise or counterclockwise
    # (should't really matter which direction, except maybe for consistency,
    # Jones et al. uses counterclockwise, see p. 1240)
    return result

# see p. 1240 of Jones et al.
def test_triangle(vertex, triangle):
    descent = calculate_steepest_descent(triangle.convert_to_array_triangle())

    ij, ik = triangle.get_edges_with_vertex(vertex)
    ij_vec = np.array([ij[1].x - ij[0].x, ij[1].y - ij[0].y])
    ik_vec = np.array([ik[1].x - ik[0].x, ik[1].y - ik[0].y])

    direction_ij = utils.cross_2D(np.array(descent), ij_vec)
    direction_ik = utils.cross_2D(np.array(descent), ik_vec)

    if direction_ij < 0 and direction_ik > 0:
        # this means that the descent is inbetween these two edges

        # TODO: should probably check that the descent vector actually descends
        return True
    
    return False

def edge_lies_in_channel(v1, v2, adj_triangle_previous, adj_triangle_next, ascend=False):
    descent_prev = calculate_steepest_descent(adj_triangle_previous.convert_to_array_triangle())
    descent_next = calculate_steepest_descent(adj_triangle_next.convert_to_array_triangle())

    edge_vector = np.array([v2.x - v1.x, v2.y - v1.y])

    direction_prev = utils.cross_2D(np.array(descent_prev), edge_vector)
    direction_next = utils.cross_2D(np.array(descent_next), edge_vector)

    if ascend and direction_prev > 0 and direction_next < 0:
        # this means that the edge lies in a channel formed by the two adjacent triangles
        return True
    elif not ascend and direction_prev < 0 and direction_next > 0:
        # this means that the edge lies in a channel formed by the two adjacent triangles
        return True

    return False


def test_edge(vertex, edge, adj_triangle_previous, adj_triangle_next):
    if adj_triangle_previous is None or adj_triangle_next is None or isinstance(adj_triangle_previous, tuple) or isinstance(adj_triangle_next, tuple):
        print()("Error: adjacent triangles cannot be None or edges")
        return False
    
    if edge[0] != vertex and edge[1] != vertex:
        print("Error: vertex must be one of the edge's vertices")
        return False
    
    # make first vertex of edge be the given vertex
    if edge[0] != vertex:
        edge = (edge[1], edge[0])
    
    if edge[0].z >= edge[1].z:
        # the edge descends in the correct direction
        if edge_lies_in_channel(edge[0], edge[1], adj_triangle_previous, adj_triangle_next):
            # also, the edge lies in a channel formed by the two adjacent triangles
            return True

    return False

def get_other_vertex_from_edge(vertex, edge):
    if edge[0] == vertex:
        return edge[1]
    elif edge[1] == vertex:
        return edge[0]
    else:
        print("Error: vertex is not part of the edge")
        return None

# ------ Main functions ------

# bounds = (max_x, max_y, min_x, min_y)
def get_subset_of_triangles_from_bounds(triangles, bounds, xs, ys):
    mask = (xs < bounds[0]) & (xs > bounds[2]) & (ys < bounds[1]) & (ys > bounds[3])

    verticies_subset = np.where(mask)
    m = np.isin(triangles, verticies_subset)
    triangles_subset = triangles[np.all(m, axis=1)]

    return triangles_subset

def calculate_steepest_descent_line(start_point, triangles, triangles_subset, xs, ys, zs, max_steps=1000):
    result = []
    result.append(start_point)

    tri = get_triangle_at(start_point, triangles_subset, xs, ys, zs)
    if tri is False:
        print("Error: could not find triangle at start point")
        return result

    s_point = start_point[0:2]
    previous_z = start_point[2]
    for i in range(1, max_steps + 1):
        full_tri = get_full_3D_triangle(tri, xs, ys, zs)

        descent = calculate_steepest_descent(full_tri)
        descent = descent / np.linalg.norm(descent)
        descent *= 0.001

        next_point, adj_tri, v1, v2 = get_point_and_adj_triangle_from_descent(tri, s_point, descent, xs, ys, zs, triangles_subset)
        if next_point is None:
            print("next_point should not be None, stopping at iteration ", i)
            break

        result.append([next_point[0], next_point[1], previous_z])

        if adj_tri is None:
            print("No adjacent triangle found, stopping at iteration ", i)
            break

        full_adj_tri = get_full_3D_triangle(adj_tri, xs, ys, zs)
        descent_adj = calculate_steepest_descent(full_adj_tri) # gh from p. 1239, Jones et al.

        full_adj_tri = make_triangle_counterclockwise(full_adj_tri)

        coord1 = get_real_vertex_3D(v1, xs, ys, zs)
        coord2 = get_real_vertex_3D(v2, xs, ys, zs)
        v1 = Vertex(coord1[0], coord1[1], coord1[2], v1)
        v2 = Vertex(coord2[0], coord2[1], coord2[2], v2)

        if (find_row_index(full_adj_tri, v1.coord()) + 1) % 3 == find_row_index(full_adj_tri, v2.coord()): # if v1 comes before v2 
            ij = v2.coord() - v1.coord()
        else: # v2 comes before v1
            # swap
            temp = v1
            v1 = v2
            v2 = temp

            ij = v2.coord() - v1.coord()

        # direction of the adj. triangle: if positive then adj. triangle slopes toward the current edge
        direction = utils.cross_2D(np.array(descent_adj), ij[0:2])
        
        if direction < 0:
            tri = adj_tri
            s_point = next_point
            continue
        else:
            lowest = None
            if v1.z > v2.z:
                lowest = v2
            else:
                lowest = v1
            
            result.append(lowest.coord())
            previous_z = lowest.z

            stop = False
            while True:
                # TODO: do not check the triangles/edges that have already been visited

                ordered = get_all_triangles_and_edges_at_point(lowest, triangles)
                color = (1, 0, 0)
                previous_item = None
                next_item = None
                j = 0
                next_point = None
                next_triangle = None
                for item in ordered:
                    previous_item = ordered[(j - 1) % len(ordered)]
                    next_item = ordered[(j + 1) % len(ordered)]

                    if isinstance(item, Triangle):
                        if test_triangle(lowest, item):
                            next_triangle = item
                    else: # must be an edge
                        # next_item and previous_item should be triangles adjacent to this edge
                        if test_edge(lowest, item, next_item, previous_item):
                            next_point = get_other_vertex_from_edge(lowest, item)
                            result.append(next_point.coord())
                            previous_z = next_point.z
                    
                    color = ((color[0] - (1.0 / 30.0)) % 1.0, color[1], color[2])
                    j += 1
                
                if next_point is not None:
                    lowest = next_point
                    continue
                elif next_triangle is not None:
                    tri = next_triangle.convert_to_indices()
                    s_point = lowest.coord()[0:2]
                    break # and then continue the outer for loop
                else:
                    # need to stop here
                    stop = True
                    break

            if stop:
                break
            else:
                continue
    
    return result


# ------ Channel network functions ------

# returns a list of Vertex objects that are on the boundary of the area
# this is done by checking if any of the connected triangles have less than 3 adjacent triangles (meaning they are on the boundary edge)
def get_vertices_on_area_bounds(vertices: dict[int, Vertex]) -> list[Vertex]:
    boundary_vertices = []
    for v in vertices.values():
        for connected_t in v.connected_triangles:
            count = 0
            for adj_t in connected_t.adjacent_triangles():
                if adj_t is not None and adj_t.triangle_has_vertex(v):
                    count += 1
            
            if count < 2:
                # must be on a boundary edge
                boundary_vertices.append(v)
                break

            #if None in connected_t.adjacent_triangles():
            #    boundary_vertices.append(v)
            #    break
    
    return boundary_vertices

# This function was generated with AI (Copilot Code Completion)
# returns a list of Vertex objects that are in pits (i.e., all connected vertices are at equal or higher elevation)
def get_vertices_in_pit(vertices: dict[int, Vertex]) -> list[Vertex]:
    pit_vertices = []
    for v in vertices.values():
        is_pit = True
        for connected_v in v.connected_vertices:
            if connected_v.z < v.z:
                is_pit = False
                break
        
        if is_pit:
            pit_vertices.append(v)
    
    return pit_vertices


def channel_flow_line_helper(vertex: Vertex, triangles: list[Triangle]):
    #ordered = get_all_triangles_and_edges_at_point(vertex, triangles)

    lines = []

    for other_vertex in vertex.connected_vertices:
        item = (vertex, other_vertex)
        adjacent_triangles = get_triangles_with_edge_new(item[0], item[1])
        if len(adjacent_triangles) < 2:
            continue

        a1 = adjacent_triangles[0]
        a2 = adjacent_triangles[1]

        a_v0 = a1.get_other_vertex(item[0], item[1])
        vec1 = np.array([a_v0.x - vertex.x, a_v0.y - vertex.y])
        vec2 = np.array([other_vertex.x - vertex.x, other_vertex.y - vertex.y])

        cross = utils.cross_2D(vec1, vec2)
        lies_in_channel = False
        if cross < 0:
            # vec1 rotated positively relative to vec2 (i.e. a1 is next triangle in counterclockwise order)
            lies_in_channel = edge_lies_in_channel(item[0], item[1], a1, a2, ascend=True)
        else:
            # vec1 rotated negatively relative to vec2 (i.e. a2 is next triangle in counterclockwise order)
            lies_in_channel = edge_lies_in_channel(item[0], item[1], a2, a1, ascend=True)
            
        ascending = item[0].z <= item[1].z

        # next_item and previous_item should be triangles adjacent to this edge
        if ascending and lies_in_channel:
            next_point = get_other_vertex_from_edge(vertex, item)
            next_lines = channel_flow_line_helper(next_point, triangles) # keep going up the channel
            new_lines = [[item[1]]]
            for line in next_lines:
                new_line = [item[1]]
                new_line.extend(line)
                new_lines.append(new_line)
            
            lines.extend(new_lines)

    
    """previous_item = None
    next_item = None
    j = 0
    next_point = None
    for item in ordered:
        previous_item = ordered[(j - 1) % len(ordered)]
        next_item = ordered[(j + 1) % len(ordered)]

        if isinstance(item, Triangle):
            pass # do nothing for triangles
        else: # must be an edge

            if item[0].id != vertex.id:
                item = (item[1], item[0]) # make first vertex be the given vertex
            
            lies_in_channel = edge_lies_in_channel(item[0], item[1], previous_item, next_item)
            ascending = item[0].z <= item[1].z

            # next_item and previous_item should be triangles adjacent to this edge
            if ascending and lies_in_channel:
                next_point = get_other_vertex_from_edge(vertex, item)
                next_lines = channel_flow_line_helper(next_point, triangles) # keep going up the channel
                new_lines = [[item[1]]]
                for line in next_lines:
                    new_line = [item[1]]
                    new_line.extend(line)
                    new_lines.append(new_line)
                
                lines.extend(new_lines)

        
        j += 1"""
    
    return lines

def channel_flow_lines_from_vertex(vertex: Vertex, triangles: list[Triangle]):
    lines = channel_flow_line_helper(vertex, triangles)
    if lines is None:
        TIN_log("ERROR: channel flow lines from vertex returned None")

    new_lines = []
    for line in lines:
        new_line = [vertex]
        new_line.extend(line)
        new_lines.append(new_line)
    return new_lines

def calculate_channel_flow_lines(vertices: dict[int, Vertex], triangles: list[Triangle]):
    print(len(vertices), " vertices available for channel flow lines")
    print(len(triangles), " triangles available for channel flow lines")
    boundary_vertices = get_vertices_on_area_bounds(vertices)
    boundary_vertices.extend(get_vertices_in_pit(vertices))
    print(len(boundary_vertices), " boundary vertices found for channel flow lines")

    all_lines = []
    for v in boundary_vertices:
        lines = channel_flow_lines_from_vertex(v, triangles)
        all_lines.extend(lines)
    
    return all_lines
    